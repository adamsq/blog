
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>adam&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="adam">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="adam's blog">
<meta property="og:url" content="http://adamsq.github.io/blog/index.html">
<meta property="og:site_name" content="adam's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="adam's blog">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="adam&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/blog/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/blog/img/20.jpg">
    <link rel="apple-touch-icon-precomposed" href="/blog/img/20.jpg">
    
    <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/blog/"><img src="/blog/img/20.png" alt="adam&#39;s blog" title="adam&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/blog/" title="adam&#39;s blog">adam&#39;s blog</a></h1>
				<h2 class="blog-motto">Angels can fly because they take themselves lightly.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/blog/">Home</a></li>
					
						<li><a href="/blog/archives">Archives</a></li>
					
						<li><a href="/blog/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:adamsq.github.io/blog">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/18/sdcc6/" title="sdcc man阅读笔记（六）——中断" itemprop="url">sdcc man阅读笔记（六）——中断</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-05-18T11:54:50.000Z" itemprop="datePublished"> 發表於 2015-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、关键字">一、关键字</h2><h3 id="1-1_interrupt&amp;using">1.1 interrupt&amp;using</h3><p>sdcc中，中断程序使用的关键字和keil一样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_isr</span> <span class="params">(<span class="keyword">void</span>)</span> __<span class="title">interrupt</span> <span class="params">(1)</span> __<span class="title">using</span> <span class="params">(1)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interrupt指定中断号，using指定register bank。</p>
<p>中断程序可以写在任意一个源文件里，但在包含main程序的源文件里，必须要有一份中断程序的声明。</p>
<p>如果使用register bank 0，那么系统会将当前程序用到的寄存器全都保存进堆栈。如果用到其他register bank，那么只会保存类似dptr这样的特殊寄存器。</p>
<h3 id="1-2_critical">1.2 critical</h3><p>critical用于表示一个程序不能被中断打算，sdcc会在运行__critical修饰的程序前保存当前中断使能状态，并关闭所有中断，运行完了之后再打开。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">int</span> <span class="tag">foo</span> () <span class="tag">__critical</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样对单独的语句也可以使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__critical&#123; i++; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、使用中断时的常见bug">二、使用中断时的常见bug</h2><h3 id="2-1_变量没有被定义为volatile">2.1 变量没有被定义为volatile</h3><p>这是个常见的错误，没有声明为volatele的变量，会使编译器对变量的读取采取优化。</p>
<h3 id="2-2_非原子指令">2.2 非原子指令</h3><p>有些c语句并非对应一句汇编指令，比如在c51下16位变量读取，可能需要2到3条指令来执行。如果在执行第一条指令时发生了中断，很有可能会产生意想不到的后果，而且这种bug很难reproduce。</p>
<h3 id="2-3_堆栈溢出">2.3 堆栈溢出</h3><p>中断程序的返回地址和保留的寄存器值全都存在堆栈里。如果在调用中断程序时，程序正好调用了多层的子程序里最深的一层，很有可能会没有足够的堆栈给中断使用。</p>
<h3 id="2-4_使用了不可重入的函数">2.4 使用了不可重入的函数</h3><p>如果中断程序里对16位/32位的变量进行了乘除、取余等操作，其实是额外调用了一些子函数，要使用—stack-auto将这些都编译为可重入函数。</p>
<p>另外，如果在中断程序中调用了其他函数（不推荐这么做），那么要使用#pragma nooverlay来避免子程序使用可覆盖的变量。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/嵌入式/">嵌入式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/18/sdcc5/" title="sdcc man阅读笔记（五）——mem文件与map文件" itemprop="url">sdcc man阅读笔记（五）——mem文件与map文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-05-18T11:39:46.000Z" itemprop="datePublished"> 發表於 2015-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、mem文件和map文件">一、mem文件和map文件</h2><p>sdcc提供mem文件和map文件来帮助我们分析一个项目编译完成后，它对各种存储空间的占用情况。</p>
<h3 id="1-1_mem文件">1.1 mem文件</h3><p>mem文件主要组成是这样的：<br>——内部ram使用表<br>——外部ram和rom使用统计表</p>
<p>打开在前一个实验里生成的test.mem查看的结果如下</p>
<blockquote>
<p>Internal RAM layout:<br>      0 1 2 3 4 5 6 7 8 9 A B C D E F<br>0x00:|0|0|0|0|0|0|0|0|a|I|S|S|S|S|S|S|<br>0x10:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x20:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x30:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x40:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x50:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x60:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x70:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x80:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0x90:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0xa0:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0xb0:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0xc0:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0xd0:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0xe0:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|<br>0xf0:|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|S|</p>
<p>0-3:Reg Banks, T:Bit regs, a-z:Data, B:Bits, Q:Overlay, I:iData, S:Stack, A:Absolute</p>
<p>Stack starts at: 0x0a (sp set to 0x09) with 246 bytes available.</p>
</blockquote>
<p>可以看到它有一个内部ram的map图，每个字节的指派都很清晰，对于外部ram和rom，也提供了一张总体统计表。</p>
<p><strong>Other memory:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Start</th>
<th>End</th>
<th>Size</th>
<th>Max</th>
</tr>
</thead>
<tbody>
<tr>
<td>PAGED EXT. RAM</td>
<td>0x0000</td>
<td>0x0000</td>
<td>1</td>
<td>256</td>
</tr>
<tr>
<td>EXTERNAL RAM</td>
<td>0x0001</td>
<td>0x0001</td>
<td>1</td>
<td>65536</td>
</tr>
<tr>
<td>ROM/EPROM/FLASH</td>
<td>0x0000</td>
<td>0x0079</td>
<td>122</td>
<td>65536</td>
</tr>
</tbody>
</table>
<h3 id="1-2_map文件">1.2 map文件</h3><p>mem文件提供的是ram和rom的总体使用统计，而map文件，则是ram和rom的详细内存使用表。</p>
<p>map文件的前两段是由链接器创建的符号表，然后再是ram的详细分段。</p>
<p>map文件的主要组成是这样的：<br>——符号表<br>——ram map<br>———ram segment REG_BANK_0<br>———ram segment DSEG<br>———ram segment …..<br>——rom map<br>———-start up<br>———-code （代码区）<br>———-const（常量区）<br>———-lib&amp;rel列表</p>
<p>在ram map中，除了分段的大小，map文件还会列出所有申明在这个区域的变量名以及该变量实际是在哪个源文件里申明的，比如DSEG段：</p>
<table>
<thead>
<tr>
<th>Area</th>
<th>Addr</th>
<th>Size</th>
<th>Decimal Bytes</th>
<th>(Attributes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>DSEG</td>
<td>00000000</td>
<td>00000080</td>
<td>128 bytes</td>
<td>(REL,CON)</td>
</tr>
</tbody>
</table>
<p><strong>地址表</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Global</th>
<th>Global Defined</th>
<th>In Module</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00000008</td>
<td>_data_v</td>
<td>test</td>
</tr>
</tbody>
</table>
<p><strong>变量表</strong></p>
<p>段表的顺序是REG_BANK_0（R0-R7)，DSEG(data)，ISEG（idata），SSEG(stack)，PSEG（pdata)，XSEG(xdata)，都是之前有提到的存储空间。</p>
<p>在rom map里，一开始是一段汇编函数的地址图，关于sdcc如何初始化单片机及c语言运行环境，之后再做分析。</p>
<p>进入代码区，我写了一个小的实验项目，它的代码区memory map是这样的：</p>
<table>
<thead>
<tr>
<th>Area</th>
<th>Addr</th>
<th>Size</th>
<th>Decimal Bytes</th>
<th>(Attributes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>CSEG</td>
<td>0000006E</td>
<td>00000282</td>
<td>642. bytes</td>
<td>(REL,CON,CODE)</td>
</tr>
</tbody>
</table>
<p><strong>code区总表</strong></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Global</th>
<th>Global Defined In Module</th>
</tr>
</thead>
<tbody>
<tr>
<td>C:</td>
<td>0000006E</td>
<td>_init_timer0</td>
<td>debug</td>
</tr>
<tr>
<td>C:</td>
<td>00000075</td>
<td>_count_runtime_start</td>
<td>debug</td>
</tr>
<tr>
<td>C:</td>
<td>00000078</td>
<td>_count_runtime_over</td>
<td>debug</td>
</tr>
<tr>
<td>C:</td>
<td>0000008D</td>
<td>_init_uart</td>
<td>debug</td>
</tr>
<tr>
<td>C:</td>
<td>0000009F</td>
<td>_uart_send_char</td>
<td>debug</td>
</tr>
<tr>
<td>C:</td>
<td>000000AD</td>
<td>_delay10ms</td>
<td>debug</td>
</tr>
<tr>
<td>C:</td>
<td>000000AE</td>
<td>_delay100cyc</td>
<td>delay</td>
</tr>
<tr>
<td>C:</td>
<td>000000B8</td>
<td>_delay10000cyc</td>
<td>delay</td>
</tr>
<tr>
<td>C:</td>
<td>000000CA</td>
<td>_HC595_Send_Data</td>
<td>display</td>
</tr>
<tr>
<td>C:</td>
<td>000000F5</td>
<td>_HC595_Set_Row</td>
<td>display</td>
</tr>
<tr>
<td>C:</td>
<td>0000012C</td>
<td>_Led_Show_Word</td>
<td>display</td>
</tr>
<tr>
<td>C:</td>
<td>0000018B</td>
<td>_Delay10ms</td>
<td>key</td>
</tr>
<tr>
<td>C:</td>
<td>000001A3</td>
<td>_Scan_key</td>
<td>key</td>
</tr>
<tr>
<td>C:</td>
<td>00000239</td>
<td>_Check_Password</td>
<td>key</td>
</tr>
<tr>
<td>C:</td>
<td>0000027C</td>
<td>_board_init</td>
<td>main</td>
</tr>
<tr>
<td>C:</td>
<td>0000028C</td>
<td>_Beer</td>
<td>main</td>
</tr>
<tr>
<td>C:</td>
<td>000002B3</td>
<td>_main</td>
<td>main</td>
</tr>
<tr>
<td>C:</td>
<td>000002EC</td>
<td>__sdcc_external_startup</td>
<td>_startup</td>
</tr>
</tbody>
</table>
<p><strong>函数表</strong></p>
<p>然后是常量区的大小和常量表（略），形式同上述data分段。</p>
<p>mem文件会分别列出每个函数在rom中的起始地址以及他们从哪里链接而来。也会给出所有链接的rel和lib</p>
<blockquote>
<p>Files Linked                              [ module(s) ]</p>
<p>build/debug.rel                           [  ]<br>build/delay.rel                           [  ]<br>build/display.rel                         [  ]<br>build/key.rel                             [  ]<br>build/main.rel                            [  ]</p>
<p>Libraries Linked                          [ object file ]</p>
<p>/usr/bin/../share/sdcc/lib/small/mcs51.lib<br>                                        [ crtclear.rel ]<br>/usr/bin/../share/sdcc/lib/small/mcs51.lib<br>                                         [ crtxinit.rel ]<br>/usr/bin/../share/sdcc/lib/small/mcs51.lib<br>                                        [ crtxclear.rel ]<br>/usr/bin/../share/sdcc/lib/small/mcs51.lib<br>                                        [ crtpagesfr.rel ]<br>/usr/bin/../share/sdcc/lib/small/mcs51.lib<br>                                        [ crtstart.rel ]<br>/usr/bin/../share/sdcc/lib/small/libsdcc.lib<br>                                        [ _startup.rel ]</p>
</blockquote>
<h2 id="二、指定分段地址">二、指定分段地址</h2><p>sdcc可以用一些链接选项来修改默认的ram/rom段的起始地址。</p>
<h3 id="2-1_—xram-loc">2.1 —xram-loc</h3><p>默认值为0，指定外部内存使用的起始地址，链接选项可以用16进制或者10进制，e.g<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--xram-loc <span class="number">0x8000</span> or --xram-loc <span class="number">32768</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-2_—code-loc">2.2 —code-loc</h3><p>修改code段在rom中的起始地址，默认为0</p>
<h3 id="2-3_—stack-loc">2.3 —stack-loc</h3><p>修改堆栈指针，如果要使用这个选项，要一并使用—no-pack-iram来关闭用寄存器优化变量的访问。</p>
<h3 id="2-4_—xstack-loc">2.4 —xstack-loc</h3><p>默认值为pdata区域之后</p>
<h3 id="2-5_—idata-loc">2.5 —idata-loc</h3><p>默认值为0x80</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/嵌入式/">嵌入式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/05/sdcc4/" title="sdcc man阅读笔记（四）——存储类型关键字" itemprop="url">sdcc man阅读笔记（四）——存储类型关键字</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-05-05T10:44:21.000Z" itemprop="datePublished"> 發表於 2015-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、存储类型关键字">一、存储类型关键字</h2><h3 id="1-1_sdcc中特殊关键字的使用">1.1 sdcc中特殊关键字的使用</h3><p>sdcc提供和keil一样的特殊关键字来指定变量的存储类型，和keil不同的是，sdcc在使用c51专用的特殊关键字时，要用两个下划线作为前缀，比如申明一个idata存储类型的变量时语句如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__idata <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br></pre></td></tr></table></figure>
<h3 id="1-2___data类型">1.2 __data类型</h3><p>该类型是small存储模式下默认使用的存储类型，对应直接寻址方式。</p>
<h3 id="1-3___pdata类型">1.3  __pdata类型</h3><p>该类型是medium存储模式下默认使用的存储类型，对应8bit的寄存器间接寻址。</p>
<h3 id="1-4___xdata类型">1.4 __xdata类型</h3><p>该类型是large存储模式下默认使用的储存类型，对应16bit的寄存器间接寻址。</p>
<h3 id="1-5___idata类型">1.5 __idata类型</h3><p>用间接寻址的方式，用这种方式可以访问片内ram的高128bit，当然也可以同时访问低128bit，只是效率会降低。之所以有这个关键字存在，应该是由于许多51单片机将最初的128bit的内部ram扩展到了256bit。它和pdata在间接寻址上的区别是无需用寄存暂存要赋值的数值。</p>
<h3 id="1-6___code类型">1.6 __code类型</h3><p>将数据存在rom中，只能存储常量。</p>
<h3 id="1-7___bit类型">1.7  __bit类型</h3><p>用来定义bit变量，51的位寻址区在内置ram的0x20-0x2f区域，共128个bit位。</p>
<h3 id="1-8___sfr类型">1.8 __sfr类型</h3><p>用来定义特殊功能寄存器</p>
<p>定义P0口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__sfr __at (<span class="number">0x80</span>) P0;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下sdcc提供的头文件里已经将51的特殊功能寄存器全都定义好了，所以这个关键字很少使用。</p>
<h3 id="1-9_不同存储空间的指针">1.9 不同存储空间的指针</h3><p>sdcc允许指针指向不同类型的存储空间，这样的指针有三个字节，第一个字节表示指向的区域。下面拷贝一段man上的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pointer physically in internal ram pointing to object in external</span><br><span class="line">ram */</span></span><br><span class="line">__xdata <span class="keyword">unsigned</span> <span class="keyword">char</span> * __data p;</span><br><span class="line"><span class="comment">/* pointer physically in external ram pointing to object in internal</span><br><span class="line">ram */</span></span><br><span class="line">__data <span class="keyword">unsigned</span> <span class="keyword">char</span> * __xdata p;</span><br><span class="line"><span class="comment">/* pointer physically in code rom pointing to data in xdata space</span><br><span class="line">*/</span></span><br><span class="line">__xdata <span class="keyword">unsigned</span> <span class="keyword">char</span> * __code p;</span><br><span class="line"><span class="comment">/* pointer physically in code space pointing to data in code space</span><br><span class="line">*/</span></span><br><span class="line">__code <span class="keyword">unsigned</span> <span class="keyword">char</span> * __code p;</span><br><span class="line"><span class="comment">/* generic pointer physically located in xdata space */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * __xdata p;</span><br><span class="line"><span class="comment">/* generic pointer physically located in default memory space */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * p;</span><br><span class="line"><span class="comment">/* the following is a function pointer physically located in data</span><br><span class="line">space */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (* __data fp)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="1-10_at关键字">1.10 at关键字</h3><p>at关键字可以指定变量的存储地址，这可以减少指针的使用，以及直接地址访问这样的语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__xdata __at (<span class="number">0x7ffe</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> chksum;</span><br><span class="line">__code __at (<span class="number">0x7ff0</span>) <span class="keyword">char</span> Id[<span class="number">5</span>] = ”SDCC”;</span><br><span class="line"><span class="keyword">volatile</span> __xdata __at (<span class="number">0x8000</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PORTA_8255;</span><br><span class="line">__bit __at (<span class="number">0x02</span>) bvar;</span><br></pre></td></tr></table></figure>
<p>使用时需要注意指定的地址是否在overlay区。</p>
<h3 id="1-11_小结">1.11 小结</h3><ul>
<li>small模式下默认使用data存储变量，medium模式下用xdata，large模式下用pdata</li>
<li>data和idata用于变量存在片内ram，xdata和pdata用于指定变量存在外部ram</li>
<li>data用于片内ram的低128bit， idata用于片内的高128bit</li>
<li>xdata用于片外ram的低256bit，pdata用于片外ram的64K</li>
<li>bit用于位寻址，sfr用于特殊功能寄存器，code用于rom</li>
</ul>
<h2 id="二、实验">二、实验</h2><p>针对sdcc的储存类型关键字，下面做一个实验来做进一步的学习。</p>
<p>首先写这样一个程序，然后编译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$vim test.c</span><br><span class="line"></span><br><span class="line">__data <span class="keyword">unsigned</span> <span class="keyword">char</span> data_v;</span><br><span class="line">__idata <span class="keyword">unsigned</span> <span class="keyword">char</span> idata_v;</span><br><span class="line">__pdata <span class="keyword">unsigned</span> <span class="keyword">char</span> pdata_v;</span><br><span class="line">__xdata <span class="keyword">unsigned</span> <span class="keyword">char</span> xdata_v;</span><br><span class="line"></span><br><span class="line">__code <span class="keyword">unsigned</span> <span class="keyword">char</span> code_v  = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line"></span><br><span class="line">        data_v =  <span class="number">1</span>;</span><br><span class="line">        idata_v = <span class="number">1</span>;</span><br><span class="line">        pdata_v = <span class="number">1</span>;</span><br><span class="line">        xdata_v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        i = code_v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看他们被分配的区域</p>
<p>data_v被分配在内部ram的前8个字节后:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;--------------------------------------------------------&#10;; overlayable register banks&#10;;--------------------------------------------------------&#10;        .area REG_BANK_0        (REL,OVR,DATA)&#10;        .ds 8&#10;;--------------------------------------------------------&#10;; internal ram data&#10;;--------------------------------------------------------&#10;        .area DSEG    (DATA)&#10;_data_v::&#10;        .ds 1</span><br></pre></td></tr></table></figure></p>
<p>idata_v被分配data之后，它之后区域就是栈区了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;--------------------------------------------------------&#10;; indirectly addressable internal ram data&#10;;--------------------------------------------------------&#10;        .area ISEG    (DATA)&#10;_idata_v::&#10;        .ds 1</span><br></pre></td></tr></table></figure>
<p>pdata和xdata都被分配在外存:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;--------------------------------------------------------&#10;; paged external ram data&#10;;--------------------------------------------------------&#10;        .area PSEG    (PAG,XDATA)&#10;_pdata_v::&#10;        .ds 1&#10;;--------------------------------------------------------&#10;; external ram data&#10;;--------------------------------------------------------&#10;        .area XSEG    (XDATA)&#10;_xdata_v::&#10;        .ds 1</span><br></pre></td></tr></table></figure>
<p>接着看对他们的处理方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;       test.c:14: data_v =  1;&#10;        mov     _data_v,#0x01&#10;;       test.c:15: idata_v = 1;&#10;        mov     r0,#_idata_v&#10;        mov     @r0,#0x01&#10;;       test.c:16: pdata_v = 1;&#10;        mov     r0,#_pdata_v&#10;        mov     a,#0x01&#10;        movx    @r0,a&#10;;       test.c:17: xdata_v = 1;&#10;        mov     dptr,#_xdata_v&#10;        mov     a,#0x01&#10;        movx    @dptr,a</span><br></pre></td></tr></table></figure>
<p>很明显，data使用了立即寻址，而pdata和xdata都使用了movx指令来访问外存。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/嵌入式/">嵌入式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/05/sdcc3/" title="sdcc man阅读笔记（三）——c51专用编译选项" itemprop="url">sdcc man阅读笔记（三）——c51专用编译选项</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-05-05T10:25:01.000Z" itemprop="datePublished"> 發表於 2015-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、C51专用编译选项">一、C51专用编译选项</h2><h3 id="1-1_C标准">1.1 C标准</h3><p>sdcc提供c89 c99 c11的三种标准，编译选项分别是</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-std-c89</span><br><span class="line"></span>-<span class="ruby">-std-c99</span><br><span class="line"></span>-<span class="ruby">-std-c11</span><br><span class="line"></span>-<span class="ruby">-std-sdcc99</span></span><br></pre></td></tr></table></figure>
<p>据说用c99，如果函数没有形参编译就不能通过，不能默认为void。在写for函数的时候，不能在第一分句里申明变量，必须提前申明。—std-sdcc99是默认的编译选项，在使用c99规范的时候，兼容c89规范，真方便。</p>
<p>anyway，我觉得很少有人会使用这个编译选项。</p>
<h3 id="1-2_芯片系列">1.2 芯片系列</h3><p>sdcc提供很多种芯片系列的选择，粗略看了一下有pic16bit，飞思卡尔，z80等等。如果是51系列的话，编译选项是-mmcs51<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-mmcs51</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3_存储模式">1.3 存储模式</h3><p>ssdc提供的memory model选项有这么几个</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-model-small</span><br><span class="line"></span>-<span class="ruby">-model-medium</span><br><span class="line"></span>-<span class="ruby">-model-large</span><br><span class="line"></span>-<span class="ruby">-model-huge</span></span><br></pre></td></tr></table></figure>
<p>small模式，对应keil的SMALL模式，变量默认存在internal ram中，该模式需要变量总占用的空间小于256bit。</p>
<p>medium模式，对应keil的COMPACT模式，变量默认存在external ram中。需要注意的是，有些51单片机本身就有内部的扩展ram，为了与旧单片机相兼容，这些内部扩展ram在名义上也算是一种外部ram。</p>
<p>large和huge模式是一样的，变量也存在external ram中，不同的是，它可以切换bank。由于c51的最大寻址范围也就是FFFFH，即64K。所以如果要扩展64K以上的ram只能用bank切换的办法。bank切换办法是用一个特殊寄存器来切换bank，将LSB存在r0，MSB存在r1，bank号存在r2。然后用 <em>__sdcc_banked_call</em>来调用位于其他bank的函数，再用<em>__sdcc_banked_ret</em>返回当前函数。</p>
<h3 id="1-4_堆栈">1.4 堆栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--xstack</span><br></pre></td></tr></table></figure>
<p>可以用xstack选项指定external ram的一段空间作为栈区（通常是前256个字节），这样所有的可重入函数的变量和参数传递都会用堆栈来实现。通常默认的栈空间是在internal ram的后区。</p>
<h3 id="1-5_size检查">1.5 size检查</h3><p>sdcc提供一些size选项来检查存储控件的使用情况</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--iram-<span class="built_in">size</span> &lt;<span class="keyword">Value</span>&gt;</span><br><span class="line">--xram-<span class="built_in">size</span> &lt;<span class="keyword">Value</span>&gt;</span><br><span class="line">--code-<span class="built_in">size</span> &lt;<span class="keyword">Value</span>&gt;</span><br><span class="line">--stack-<span class="built_in">size</span> &lt;<span class="keyword">Value</span>&gt;</span><br></pre></td></tr></table></figure>
<p>iram-size 用来检查片内ram的使用情况<br>xram-size 用来检查外部ram的使用情况<br>code-size 用来检查rom的使用情况<br>stack-size 用来检查堆栈的使用情况</p>
<h3 id="1-6_寄存器优化开关">1.6 寄存器优化开关</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--pack-iram</span><br><span class="line">--no-pack-iram</span><br></pre></td></tr></table></figure>
<p>—pack-iram是默认选项，意思是将多余的寄存器用来存放变量，以加快运行速度。因为这是一种通俗的做法，所以—no-pack-iram选项几乎很少使用，编译器的作者说下一版将移除这个选项。如果想不让编译器优化某个变量的访问，直接使用volatile关键字就可以了。假如担心一个全局变量会被中断程序或者其他线程修改，那么声明它为volatile就可以了，编译器会让该变量在每次访问时都重新从内存读取。</p>
<h3 id="1-7_汇编优化">1.7 汇编优化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--acall-ajmp</span><br></pre></td></tr></table></figure>
<p>—acall-ajmp选项用来将3字节的汇编指令lcall/ljpm替换成2字节的指令acall-ajmp，这就要求代码总占用空间限制在2K以内。</p>
<p>我很好奇这个选项的使用场景，于是在github上搜索了一下，发现它通常用于一些微型的bootloader。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--no-ret-without-call</span><br></pre></td></tr></table></figure>
<p>—no-ret-without-call 用于xc800系列的单片机，用于保持堆栈平衡。</p>
<h2 id="总结">总结</h2><ul>
<li>sdcc用-mmcs51来指定单片机为51系列</li>
<li>sdcc有与keil相同的memory model</li>
<li>可以用编译选项告诉编译器程序使用外部ram里的堆栈</li>
<li>可以用编译选项检查各存储空间的占用情况</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/嵌入式/">嵌入式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/04/sdcc2/" title="sdcc man阅读笔记（二）——基础编译选项&amp;output files" itemprop="url">sdcc man阅读笔记（二）——基础编译选项&amp;output files</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-05-04T13:12:25.000Z" itemprop="datePublished"> 發表於 2015-05-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、基础编译选项">一、基础编译选项</h2><h3 id="1-1_单源文件的编译">1.1 单源文件的编译</h3><p>假设目前有一个源文件led.c，可以用如下命令进行编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sdcc</span> led.c</span><br></pre></td></tr></table></figure>
<p>编译完之后发现目录下好多生成的编译文件。其中led.rel是类似gcc中的led.o这样用于链接的对象文件，有所不同的是，led.rel中并不包含链接用的汇编代码，它包含在led.lst中。而led.ihx是用来烧写的hex文件，它的格式是intel hex规范。实际用于烧写的文件格式要根据烧写工具来定制，这一点之后再研究。</p>
<h3 id="1-2_多源文件的编译">1.2 多源文件的编译</h3><p>在另外一个项目中，共有4个源文件。key.c用来控制矩阵键盘，display.c用来操作点阵屏，uart.c用来实现串行通信，而main.c用来统一调用其他源文件里的函数。</p>
<p>这几个源文件编译的方法是先将源文件编译成库，然后再统一链接。使用编译选项 -c 表示complier only，只编译不链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sdcc</span> -c key.c</span><br><span class="line"><span class="variable">$sdcc</span> -c display.c</span><br><span class="line"><span class="variable">$sdcc</span> -c uart.c</span><br><span class="line"><span class="variable">$sdcc</span> main.c key.rel display.rel uart.rel</span><br></pre></td></tr></table></figure>
<p>当然也可以将最后一条命令这样做，统一将源码先全部编译成链接库，这样在写makefile时会更方便。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sdcc</span> -c main.c</span><br><span class="line"><span class="variable">$sdcc</span> main.rel key.rel display.rel uart.rel</span><br></pre></td></tr></table></figure>
<h3 id="1-3_库文件的链接">1.3 库文件的链接</h3><p>在上述的项目里，uart.c的其中一个函数用到了crc校验，它的函数原型在另外的crc.lib库文件中，编译的时候要额外链接该库文件。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sdcc</span> -c uart<span class="class">.c</span> crc.lib</span><br></pre></td></tr></table></figure>
<p>如果库文件不在当前目录要用 -L 选项制定目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sdcc</span> -c uart.c -L /usr/crc.lib</span><br></pre></td></tr></table></figure>
<p>使用sdcclib命令，可以将对象文件链接成lib文件。</p>
<p>用sdcclib -s和 sdcclib -m可以查看lib文件的符号表和函数表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sdcclib</span> led.lib led.rel</span><br><span class="line"><span class="variable">$sdcclib</span> project.lib led.rel display.rel key.rel</span><br><span class="line"></span><br><span class="line"><span class="variable">$sdcclib</span> <span class="operator">-s</span> led.lib</span><br><span class="line"><span class="variable">$sdcclib</span> -m projext.lib</span><br></pre></td></tr></table></figure>
<h2 id="二、output_file">二、output file</h2><p>使用sdcc led.c后发现目录下一大堆编译生成的文件，来看看这些文件都是用来做什么的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span></span><br><span class="line">led.asm led.lst led.rst led.sym led.rel led.map led.mem</span><br></pre></td></tr></table></figure>
<h3 id="2-1_asm文件">2.1 asm文件</h3><p>由complier创建，是c源码文件编译成汇编后的结果。在分析一些具体问题的时候，可能会需要去查看编译出来的汇编指令。</p>
<h3 id="2-2_lst文件">2.2 lst文件</h3><p>由assembler创建，我对比了同一个源文件生成的lst文件和asm文件，两者差不多。不同的是lst在行首有每一行的相对地址，而asm则没有，但asm有用标示符来标示一些用于跳转的地址，方便我们查看。</p>
<h3 id="2-3_rst文件">2.3 rst文件</h3><p>由linker创建，它和lst的文件的区别是，lst行首的相对地址变更成了链接时使用的地址，将一些栈区与堆区的地址加入了文件，使原文件的指令地址发生了偏移。</p>
<h3 id="2-4_sym文件">2.4 sym文件</h3><p>由assembler创建，该文件包含的是当前源文件的符号表。</p>
<h3 id="2-5_rel文件">2.5 rel文件</h3><p>由assembler创建，该文件被用于链接。</p>
<h3 id="2-6_map文件">2.6 map文件</h3><p>由linker创建，该文件包含有最终生成的目标文件的地址图，标明了所有函数在最终目标文件里的位置，以及是从哪个模块链接过来的。</p>
<h3 id="2-7_mem文件">2.7 mem文件</h3><p>该文件里显示目标文件运行时RAM和堆栈的使用情况。</p>
<h2 id="总结">总结</h2><ul>
<li>单源文件的工程可以使用sdcc source.c来编译。</li>
<li>多元文件的工程可以将源码编译成rel文件，再统一链接。</li>
<li>sdcc编译成功后会生成许多文件。</li>
<li>lst rst rel sym文件用于编译过程，如果编译没有出现问题，可以不用去看这些文件。</li>
<li>asm用于显示源文件的汇编代码，在解决一些优化及疑难问题时要去查看该文件。</li>
<li>map和mem文件可以帮助我们分析该项目对单片机存储资源的占用情况。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/嵌入式/">嵌入式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/04/sdcc1/" title="sdcc man阅读笔记（一）——sdcc 的介绍与安装" itemprop="url">sdcc man阅读笔记（一）——sdcc 的介绍与安装</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-05-04T12:24:25.000Z" itemprop="datePublished"> 發表於 2015-05-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、前言">一、前言</h2><p>最近打算写一些单片机程序，因此买了一块51开发板，打算写几个有趣的程序。</p>
<p>出于将学习和娱乐分开的目的，我把编程工作放在linux下来进行。</p>
<p>在linux下进行单片机的软件开发，要先安装专用的交叉编译器sdcc。接下来我会阅读sdcc的man文档，再结合一些简单的实验，来了解一下这款编译器。其目的有三，一是复习一些单片机的知识，为编程做点准备。二是理清sdcc的编译选项，好用来写makefile。三是弄明白sdcc和keil编译器的不同，这样可以把keil c的代码移植过来直接使用。</p>
<h2 id="二、sdcc的安装">二、sdcc的安装</h2><h3 id="1-1_在ubuntun下安装sdcc">1.1 在ubuntun下安装sdcc</h3><p>由于我的系统是ubuntun，因此可以直接使用apt-get命令来进行安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get install sdcc</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2_用其他方式安装sdcc">1.2 用其他方式安装sdcc</h3><p>非ubuntun环境下，可以下载sdcc源码并编译生成sdcc，这样可以得到目前的最高版本。</p>
<p>sdcc源码的下载地址是 <a href="http://sdcc.sourceforge.net/snap.php" target="_blank" rel="external">http://sdcc.sourceforge.net/snap.php</a> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tar</span> -xvjf sdcc-src-yyyymmdd-rrrr.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="variable">$cd</span> sdcc</span><br><span class="line">$./configure</span><br><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$make</span> install</span><br></pre></td></tr></table></figure>
<p><strong>sdcc man文件下载地址</strong> <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf" target="_blank" rel="external">http://sdcc.sourceforge.net/doc/sdccman.pdf</a></p>
<h2 id="三、sdcc包含的内容">三、sdcc包含的内容</h2><p>安装完sdcc后可以分析一下sdcc一共包含哪些组成部分。</p>
<h3 id="2-1_头文件和库文件">2.1 头文件和库文件</h3><p>sdcc的头文件和库文件在 installdir/share/sdcc目录下，除此之外的所有bin文件包含在<installdir>/bin目录下。</installdir></p>
<blockquote>
<p>installdir/share/sdcc/include<br>installdir/share/sdcc/lib</p>
<p>installdir/bin</p>
</blockquote>
<p>installdir默认的值为/usr。</p>
<h3 id="2-2_编译程序sdcc">2.2 编译程序sdcc</h3><p>编译程序sdcc，最常用到的命令，它所做的其实就是轮流调用预处理器、汇编器、连接器来完成编译工作。</p>
<h3 id="2-3_预处理程序sdccp">2.3 预处理程序sdccp</h3><p>这个预编译程序sdccp是直接用gcc的预编译程序的源码修改而来的，它被用来在编译前处理#include #define 这些预编译指令。</p>
<h3 id="2-4_汇编程序和链接程序sdas,_sdld">2.4 汇编程序和链接程序sdas, sdld</h3><p>sdas用来将C源码编译成汇编指令，sdld用来链接各目标文件的符号表。顺带一提man文档上说这两个程序都是基于<strong>Alan Baldwin</strong>的开源代码修改的，现在用的是它的2.0版本。<strong>Alan Baldwin</strong>已经将它的5.0版本开源，该老兄一直致力于编译器的研发工作。</p>
<h3 id="2-5_仿真器">2.5 仿真器</h3><p>sdcc集成的仿真器包含s51, sz80 shc08 and sstm8系统，由<strong>Daniel Drotos</strong>开发，在他的网站上有详细的说明: </p>
<p><a href="http://mazsola.iit.uni-miskolc.hu/~drdani/embedded/s51" target="_blank" rel="external">http://mazsola.iit.uni-miskolc.hu/~drdani/embedded/s51</a></p>
<h3 id="2-6_debug工具_sdcdb">2.6 debug工具 sdcdb</h3><p>sdcc用<strong>Daniel Drotos</strong>的仿真器进行debug，由于我有开发板，可以直接把程序烧上去。而且该款单片机没有j-tag接口，所以等有时间再来研究这个debug工具吧。</p>
<h2 id="总结">总结</h2><ul>
<li>在linux下进行单片机开发可以使用交叉编译器sdcc</li>
<li>sdcc包含有一个编译程序、预处理程序、汇编程序和链接程序。</li>
<li>sdcc还包含有一个集成的仿真器和debug工具。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/嵌入式/">嵌入式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/04/21/hexo/" title="hexo" itemprop="url">hexo</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="adam" target="_blank" itemprop="author">adam</a>
		
  <p class="article-time">
    <time datetime="2015-04-21T13:36:31.000Z" itemprop="datePublished"> 發表於 2015-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一、建立hexo站点">一、建立hexo站点</h2><h3 id="1-1安装node-js">1.1安装node.js</h3><p>由于hexo基于node.js环境，所以在建立hexo站点前必须先安装node.js环境。</p>
<p>我的系统是从unbuntu官网下载的unbuntu14.04 32bit。如果是windows用户，可以安装node.js的windows版本，官网上也提供win版本的下载链接。</p>
<p>在 <a href="http://nodejs.org" target="_blank" rel="external">http://nodejs.org/</a> 上下载node.js的最新源码，然后使用make install 进行编译，即可在系统里生成node.js的环境。编译了半小时才完成，居然没有报任何错误，so lucky!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
<h3 id="1-2安装hexo">1.2安装hexo</h3><p>装完了node.js就可以安装hexo了，使用npm命令直接安装hexo及它的命令行工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h3 id="1-3建立站点">1.3建立站点</h3><p>使用 <a href="http://hexo.io" target="_blank" rel="external">http://hexo.io</a> 上的例子可以快速创建一个hexo站点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>完成了这个步骤之后，可以看到站点的相关文件都已经在blog目录下建立完毕。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>之后使用hexo server可以在本地浏览该站点，默认的地址是 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<h2 id="二、修改hexo站点">二、修改hexo站点</h2><h3 id="2-1修改主题">2.1修改主题</h3><p>本站用的是 <a href="http://hexo.io" target="_blank" rel="external">http://hexo.io</a> 上theme页的jacman主题，先从git上下载下来，然后修改hexo目录下_config.yml的文件即可设置新主题。如果想要定制化hexo，除了看_config.yml里的注释，还可以把官网上的doc看一篇。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$vim</span> _config.yml</span><br><span class="line">  theme: jacman</span><br></pre></td></tr></table></figure>
<h3 id="2-2新建文章">2.2新建文章</h3><p>用hexo new命令可以创建一篇新的文章，然后用编辑器编辑即可，支持Markdown语法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new hexo</span><br><span class="line">vim <span class="built_in">source</span>/_posts/hexo.md</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3与github同步">2.3与github同步</h3><p>hexo可以实现一键同步，它提供很多种提交方式，git是最常用的一种。要用git进行提交，先要设置好git用ssh访问，安装hexo的git工具，然后修改_config.yml的设置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">vim _config.yml</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><ul>
<li>hexo依赖于node.js，在安装前必须先架设node.js环境。</li>
<li>hexo内置与github服务器同步的命令，前提是安装好git，并在配置文件下设置git的相关配置。</li>
<li>使用hexo server命令可以在本地查看站点，再用hexo d命令与github进行一键同步。</li>
<li>用hexo new命令创建文章，并用Markdown语法直接编辑文件。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/blog/tags/java-web/">java&web</a><a href="/blog/tags/linux/">linux</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/blog/tags/嵌入式/" title="嵌入式">嵌入式<sup>6</sup></a></li>
			
		
			
				<li><a href="/blog/tags/java-web/" title="java&amp;web">java&amp;web<sup>1</sup></a></li>
			
		
			
				<li><a href="/blog/tags/linux/" title="linux">linux<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Adam ,a fat guy who will never stop eating. <br/>
			Nice to meet you.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/adamsq" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:adam_embedded@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/blog/about" target="_blank" title="adam">adam</a>
		
		
		</p>
</div>
</footer>
    <script src="/blog/js/jquery-2.0.3.min.js"></script>
<script src="/blog/js/jquery.imagesloaded.min.js"></script>
<script src="/blog/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/blog/img/scrollup.png"/></a>
	</div>
	<script src="/blog/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
